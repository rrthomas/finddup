#! /usr/bin/perl
#
# finddup - find identical files and do something with them.
#

$VERSION = '2.4';

use strict;
use warnings;

use File::Find ();
use Digest::MD5;
use Getopt::Long;
use Pod::Usage;

use JSON; # Requires 3rd-party JSON library, but allows distros to
          # automagically substitute JSON::XS for JSON::PP for better
          # performance


# for the convenience of &wanted calls, including -eval statements:
use vars qw(*name *dir *prune);
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

use vars qw($RCS_VERSION $VERSION @dir $opt %filelist %md5list);

sub wanted;
sub insert_md5;

GetOptions($opt = {}, qw(help|h man version noaction|n ignore-perms|i json verbose|v quiet|q link|l oldresult|o dir=s@)) || pod2usage 2;
pod2usage(1) if $opt->{help};
pod2usage(-exitstatus => 0, -verbose => 2) if $opt->{man};
if ($opt->{version}) { print "Version: $VERSION\n"; exit 0; }
# Force some options
$opt->{verbose} = 1 if not exists $opt->{verbose} and $opt->{noaction};
$opt->{link} = 1 if not exists $opt->{link} and $0 =~ /^(.*\/)?nodup(.pl)?$/;
$opt->{oldresult} = 1 if not exists $opt->{oldresult} and $0 =~ /^(.*\/)?nodup(.pl)?$/;

my @dir = @{$opt->{dir}} if ($opt->{dir});
push @dir, '.' if scalar(@dir) eq 0;

if ($opt->{oldresult}) {
   my $md5 = 0; # This is not really necessary in this mode, so make this faster
   while (<>)
   {
      chomp;
      my ($size, @files);
      if ($opt->{json}) {
         my $jsonval = decode_json($_);
         $size = @{$jsonval}[0];
         @files = @{$jsonval}[1..-1];
      } else {
         s/^(\d+) '//;
         $size = $1;
         s/'$//;
         @files = split(/' '/);
      }
      $md5list{$md5++} = [[$size, 0, 0, 0, \@files]];
   }
} else {
   # Traverse desired filesystems
   File::Find::find({wanted => \&wanted}, @dir);

   my ($prev, $prev2) = ([-1], [-2]);

   # Now calculate md5sums for each file that has another file of the same
   # size. Afterwards %filelist can be freed.
   foreach (sort {$a->[0] cmp $b->[0]} values(%filelist))
   {
      insert_md5($prev) if $_->[0] == $prev->[0] || $prev->[0] == $prev2->[0];
      $prev2 = $prev;
      $prev = $_;
   }
   insert_md5($prev) if $prev->[0] == $prev2->[0];
   %filelist = ();
}

# Now we can output doubles sorted by size
foreach (sort {$md5list{$b}->[0]->[0] <=> $md5list{$a}->[0]->[0]} keys(%md5list)) {
   next unless @{$md5list{$_}} > 1 or $opt->{oldresult}; # This file is single
   my $size = $md5list{$_}->[0]->[0];
   if ($size) { # Do not output empty files
      if ($opt->{link}) {
	 my $reffile = shift @{$md5list{$_}->[0]->[4]}; # Remove the first file to not unlink them
	 print "Length: $size Files:\t$reffile\n" if $opt->{verbose};
	 foreach (@{$md5list{$_}}) {
	    foreach (@{$_->[4]}) {
	       print "\t\t\t$_\n" if $opt->{verbose};
	       unless ($opt->{noaction}) {
		  unlink $_ || die "Error deleting '$_'";
		  link $reffile, $_ || die "Error in ln '$reffile' '$_'";
	       }
	    }
	 }
	 print "\n" if $opt->{verbose};
      } elsif (!$opt->{quiet}) {
         my @output;
	 foreach (@{$md5list{$_}}) {
            push @output, $_ foreach @{$_->[4]};
	 }
         if ($opt->{json}) {
            print encode_json([$size, @output]);
         } else {
            print $size;
            print " '$_'" foreach @output;
         }
         print "\n";
      }
   }
}

exit 0;


sub wanted {
   my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size);

   if ((($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size) = lstat($_)) && !($File::Find::prune |= ($dev != $File::Find::topdev)) && -f _) {
      $filelist{$ino} = [$size, $mode, $uid, $gid, []] unless exists $filelist{$ino};
      push @{$filelist{$ino}->[4]}, $name;
   }
}

sub insert_md5
{
   my $file = shift;
   if (open(IN, "<", $file->[4]->[0])) {
      my $md5 = Digest::MD5->new->addfile(*IN)->hexdigest;
      $md5 .= "\t".$file->[1]."\t".$file->[2]."\t".$file->[3] unless $opt->{'ignore-perms'};
      close IN;
      $md5list{$md5} = [] unless exists $md5list{$md5};
      push @{$md5list{$md5}}, $file;
   } else {
      warn "Cannot open file '" . $file->[4]->[0] . "'";
   }
}

__END__

=head1 NAME

finddup - Find identical files and do something with them

=head1 SYNOPSIS

B<finddup> [I<options>...]

     --man              the manpage
 -h, --help             a short help
     --version          the version of the program
 -n, --noaction         do just nothing, just print out (implies -v)
 -v, --verbose          just what the name says
     --json             output/input JSON
 -q, --quiet            be quiet
 -l, --link	        link the identical files together
 -o, --oldresult        Use the old output of this script
 -i, --ignore-perms     Don't check that file owner and permissions match
 -d, --dir              Define the dir to check (you may specify more than one)

=head1 DESCRIPTION

finddup searches the working directory and all files below on the same partition
for duplicate files.

finddup can optionally hardlink such files to save space.

Files of size 0 will not be reported or hardlinked as this might cause problems.

If run as nodup or nodup.pl the script will act as if started with options --link
--oldresult

=head1 AUTHOR

Copyright (c) 2005 S<Klaus Ethgen E<lt>Klaus@Ethgen.de<gt>>

Copyright (c) 2017 S<Reuben Thomas E<lt>rrt@sc3d.org<gt>>

=cut
